---
alwaysApply: true
---
```yaml
---
tags: [Phoenix-Code-Lite, TypeScript, Code, Standards]
provides: []
requires: []
```

# TypeScript Code Standards for Phoenix Code Lite

## üéØ Overview

Phoenix Code Lite follows strict TypeScript coding standards to ensure maintainability, readability, and type safety. These standards are enforced through ESLint, Prettier, and TypeScript compiler settings.

## üìù TypeScript Configuration

### Compiler Settings (tsconfig.json)

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "lib": ["ES2020"],
    "strict": true,                    // Enable all strict type checks
    "noImplicitAny": true,            // Disallow implicit 'any' types
    "strictNullChecks": true,         // Enable strict null checks
    "strictFunctionTypes": true,       // Enable strict function type checks
    "noImplicitReturns": true,        // Report error on unreachable code
    "noImplicitThis": true,           // Report error on 'this' expressions
    "noUnusedLocals": true,           // Report error on unused locals
    "noUnusedParameters": true,       // Report error on unused parameters
    "exactOptionalPropertyTypes": true // Exact optional property types
  }
}
```

### ESLint Configuration (eslint.config.js)

```javascript
module.exports = {
  parser: '@typescript-eslint/parser',
  plugins: ['@typescript-eslint'],
  extends: [
    'eslint:recommended',
    '@typescript-eslint/recommended',
    '@typescript-eslint/recommended-requiring-type-checking'
  ],
  rules: {
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/explicit-function-return-type': 'error',
    '@typescript-eslint/no-explicit-any': 'error',
    '@typescript-eslint/prefer-readonly': 'error'
  }
};
```

## üèóÔ∏è Code Structure Standards

### File Organization

```typescript
// File header structure
import { ... } from 'node:...';      // Node.js built-in modules first
import { ... } from 'external-package'; // External packages second
import { ... } from '../internal';      // Internal modules last

// Type definitions and interfaces
export interface ComponentInterface {
  // Interface definition
}

// Implementation classes
export class ComponentImplementation implements ComponentInterface {
  // Implementation
}

// Utility functions (if any)
export function utilityFunction(): returnType {
  // Function implementation
}
```

### Import/Export Standards

```typescript
// Prefer named exports over default exports
export class TDDOrchestrator { }
export interface TaskContext { }

// Use named imports
import { TDDOrchestrator, TaskContext } from './tdd/orchestrator';

// Avoid default exports except for configuration objects
export default {
  // Configuration object only
};
```

## üîß Type Safety Standards

### Interface Design

```typescript
// Use strict interface definitions
export interface TaskContext {
  readonly taskDescription: string;    // Use readonly for immutable properties
  readonly projectPath: string;
  readonly language?: string;          // Optional properties clearly marked
  readonly framework?: string;
  readonly maxTurns: number;          // Required properties not optional
}

// Use discriminated unions for type safety
export type WorkflowPhase = 
  | { type: 'plan-test'; data: PlanTestData }
  | { type: 'implement-fix'; data: ImplementData }
  | { type: 'refactor-document'; data: RefactorData };
```

### Function Signatures

```typescript
// Explicit return types for all functions
export async function executeWorkflow(
  taskDescription: string, 
  context: TaskContext
): Promise<WorkflowResult> {
  // Implementation
}

// Use readonly for array parameters that shouldn't be mutated
export function processPhases(
  phases: readonly PhaseResult[]
): ProcessedResult {
  // Implementation that doesn't mutate phases
}

// Use type guards for runtime type checking
export function isValidTaskContext(obj: unknown): obj is TaskContext {
  return typeof obj === 'object' 
    && obj !== null 
    && 'taskDescription' in obj 
    && 'projectPath' in obj;
}
```

### Error Handling with Types

```typescript
// Use custom error types with proper inheritance
export class ValidationError extends Error {
  public readonly code: string;
  public readonly context: Record<string, unknown>;

  constructor(message: string, code: string, context: Record<string, unknown> = {}) {
    super(message);
    this.name = 'ValidationError';
    this.code = code;
    this.context = context;
  }
}

// Use Result types for operations that can fail
export type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E };

export async function validateInput(input: unknown): Promise<Result<TaskContext, ValidationError>> {
  try {
    const validated = TaskContextSchema.parse(input);
    return { success: true, data: validated };
  } catch (error) {
    return { 
      success: false, 
      error: new ValidationError('Validation failed', 'VALIDATION_ERROR', { input })
    };
  }
}
```

## üé® Naming Conventions

### Variables and Functions

```typescript
// Use camelCase for variables and functions
const taskDescription = 'Create email validation';
const maxRetryAttempts = 3;

function executeWorkflow(): void { }
function validateUserInput(): void { }

// Use descriptive names that explain purpose
// Good
const userConfigurationTemplate = loadTemplate();
const isValidEmailAddress = validateEmail(email);

// Bad
const temp = loadTemplate();
const valid = validateEmail(email);
```

### Classes and Interfaces

```typescript
// Use PascalCase for classes and interfaces
export interface TaskContext { }
export interface WorkflowResult { }

export class TDDOrchestrator { }
export class SecurityGuardrailsManager { }

// Use descriptive class names that indicate responsibility
export class ClaudeCodeClient { }          // Clear: handles Claude Code integration
export class ProgressTracker { }           // Clear: tracks progress
export class QualityGateManager { }        // Clear: manages quality gates
```

### Constants and Enums

```typescript
// Use UPPER_SNAKE_CASE for constants
export const DEFAULT_MAX_TURNS = 3;
export const QUALITY_GATE_THRESHOLD = 0.9;
export const SUPPORTED_LANGUAGES = ['typescript', 'javascript', 'python'] as const;

// Use PascalCase for enums
export enum WorkflowStatus {
  Pending = 'pending',
  InProgress = 'in_progress',
  Completed = 'completed',
  Failed = 'failed'
}
```

### File and Directory Names

``` text
// Use kebab-case for file names
tdd-orchestrator.ts
quality-gates.ts
claude-code-client.ts

// Use camelCase for directory names when representing modules
src/
‚îú‚îÄ‚îÄ tdd/                    # TDD module
‚îú‚îÄ‚îÄ claude/                 # Claude integration module
‚îú‚îÄ‚îÄ cli/                    # CLI module
‚îî‚îÄ‚îÄ utils/                  # Utilities module
```

## üîí Security-Conscious Coding

### Input Validation

```typescript
// Always validate inputs with Zod schemas
import { z } from 'zod';

export const TaskContextSchema = z.object({
  taskDescription: z.string().min(10).max(1000),
  projectPath: z.string().min(1),
  language: z.string().optional(),
  framework: z.string().optional(),
  maxTurns: z.number().min(1).max(10).default(3)
});

// Use type-safe validation in functions
export function validateTaskContext(input: unknown): TaskContext {
  return TaskContextSchema.parse(input);
}
```

### Secure File Operations

```typescript
// Use security guardrails for all file operations
export async function readProjectFile(
  filePath: string, 
  context: TaskContext
): Promise<string> {
  // Validate path through security guardrails
  const securityResult = await securityManager.validateFileAccess(filePath, 'read', context);
  
  if (!securityResult.allowed) {
    throw new SecurityViolationError('File access denied', securityResult.violations);
  }
  
  return await fs.readFile(filePath, 'utf-8');
}
```

### Sensitive Data Handling

```typescript
// Never log sensitive information
export class AuditLogger {
  public async logWorkflowStart(
    taskDescription: string, 
    context: TaskContext
  ): Promise<void> {
    // Sanitize context before logging
    const sanitizedContext = this.sanitizeContext(context);
    
    await this.log({
      eventType: 'workflow_start',
      taskDescription,
      context: sanitizedContext,  // Never log raw context
      timestamp: new Date()
    });
  }

  private sanitizeContext(context: TaskContext): Record<string, unknown> {
    return {
      projectPath: this.sanitizePath(context.projectPath),
      language: context.language,
      framework: context.framework,
      maxTurns: context.maxTurns
      // Exclude any potentially sensitive information
    };
  }
}
```

## üìä Performance Standards

### Efficient Data Structures

```typescript
// Use readonly for immutable data
export interface WorkflowResult {
  readonly taskDescription: string;
  readonly phases: readonly PhaseResult[];
  readonly success: boolean;
  readonly artifacts: readonly string[];
}

// Use Map and Set for efficient lookups
export class ComponentRegistry {
  private readonly components = new Map<string, Component>();
  private readonly activeComponents = new Set<string>();

  public registerComponent(name: string, component: Component): void {
    this.components.set(name, component);
  }

  public isActive(name: string): boolean {
    return this.activeComponents.has(name);
  }
}
```

### Async/Await Best Practices

```typescript
// Use async/await consistently
export async function executePhases(
  phases: readonly PhaseConfig[]
): Promise<PhaseResult[]> {
  const results: PhaseResult[] = [];
  
  // Sequential execution when order matters
  for (const phase of phases) {
    const result = await this.executePhase(phase);
    results.push(result);
  }
  
  return results;
}

// Use Promise.all for parallel operations when appropriate
export async function validateMultipleFiles(
  filePaths: readonly string[]
): Promise<ValidationResult[]> {
  const validationPromises = filePaths.map(path => this.validateFile(path));
  return await Promise.all(validationPromises);
}
```

## üß™ Testing-Friendly Code

### Dependency Injection

```typescript
// Use dependency injection for testability
export class TDDOrchestrator {
  constructor(
    private readonly claudeClient: ClaudeCodeClient,
    private readonly auditLogger: AuditLogger,
    private readonly securityManager: SecurityGuardrailsManager
  ) {}

  // Methods can be tested by injecting mocks
}

// Factory function for production use
export function createTDDOrchestrator(): TDDOrchestrator {
  const claudeClient = new ClaudeCodeClient();
  const auditLogger = new AuditLogger();
  const securityManager = new SecurityGuardrailsManager();
  
  return new TDDOrchestrator(claudeClient, auditLogger, securityManager);
}
```

### Pure Functions Where Possible

```typescript
// Pure functions are easier to test
export function calculateQualityScore(
  results: readonly QualityGateResult[]
): number {
  if (results.length === 0) return 0;
  
  const totalScore = results.reduce((sum, result) => sum + result.score, 0);
  return totalScore / results.length;
}

// Separate pure logic from side effects
export class MetricsCollector {
  public async recordWorkflow(result: WorkflowResult): Promise<void> {
    // Pure calculation
    const metrics = this.calculateMetrics(result);
    
    // Side effect (I/O operation)
    await this.persistMetrics(metrics);
  }

  private calculateMetrics(result: WorkflowResult): WorkflowMetrics {
    // Pure function - no side effects
    return {
      duration: result.duration || 0,
      phaseCount: result.phases.length,
      successRate: result.success ? 1 : 0,
      qualityScore: this.calculateQualityScore(result.phases)
    };
  }
}
```

## üìö Documentation Standards

### JSDoc Comments

```typescript
/**
 * Executes a complete TDD workflow for the given task description.
 * 
 * @param taskDescription - Natural language description of the task to implement
 * @param context - Task execution context and configuration
 * @returns Promise that resolves to workflow execution results
 * @throws {ValidationError} When task context is invalid
 * @throws {SecurityViolationError} When security constraints are violated
 * 
 * @example
 * ```typescript
 * const orchestrator = new TDDOrchestrator(claudeClient);
 * const result = await orchestrator.executeWorkflow(
 *   'Create email validation function',
 *   { projectPath: './my-project', maxTurns: 3 }
 * );
 * console.log(`Workflow ${result.success ? 'succeeded' : 'failed'}`);
 * ```
 */
export async function executeWorkflow(
  taskDescription: string,
  context: TaskContext
): Promise<WorkflowResult> {
  // Implementation
}
```

### Type Documentation

```typescript
/**
 * Configuration context for TDD workflow execution.
 * 
 * @interface TaskContext
 */
export interface TaskContext {
  /** Natural language task description (10-1000 characters) */
  readonly taskDescription: string;
  
  /** Absolute path to the project directory */
  readonly projectPath: string;
  
  /** Programming language hint for code generation */
  readonly language?: string;
  
  /** Framework hint for implementation (e.g., 'react', 'express') */
  readonly framework?: string;
  
  /** Maximum number of implementation attempts (1-10, default: 3) */
  readonly maxTurns: number;
}
```

## ‚úÖ Code Quality Checklist

### Before Committing Code

- [ ] **TypeScript compilation** - Code compiles without errors or warnings
- [ ] **ESLint validation** - All linting rules pass (target: >95% score)
- [ ] **Type safety** - No `any` types, proper type annotations
- [ ] **Test coverage** - New code has >90% test coverage
- [ ] **Documentation** - Public APIs documented with JSDoc
- [ ] **Security review** - Security best practices followed
- [ ] **Performance consideration** - No obvious performance issues

### Code Review Standards

- [ ] **Naming clarity** - Variable and function names are descriptive
- [ ] **Function size** - Functions are focused and not too long (typically <50 lines)
- [ ] **Complexity** - Cyclomatic complexity is reasonable
- [ ] **Error handling** - Proper error handling with typed errors
- [ ] **Resource management** - Proper cleanup of resources
- [ ] **Security implications** - No security vulnerabilities introduced

---

**Remember**: Code is read more often than it's written. Prioritize clarity, maintainability, and type safety to create code that serves the team and users well over time.
