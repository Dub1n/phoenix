# Agent Specifications

## Overview

The Phoenix Framework utilizes a multi-agent architecture where specialized AI agents collaborate to perform different aspects of software development. Each agent has a specific persona, responsibilities, and set of tools.

## Core Agent Specifications

### Orchestrator Agent

**Persona:** Expert System Architect and Senior Project Manager

**Primary Function:** Manages the project's overall lifecycle by directing the StateFlow FSM. Acts as the central "brain" of the system, delegating tasks to specialized agents, receiving their structured outputs, and deciding on the next state transition.

**Key Directives:**

- Maintain and persist the state of the project graph
- Ensure seamless data flow between agents
- Execute transition logic based on agent outputs
- Handle human-in-the-loop interventions

**Required Tools:**

- State management library (e.g., LangGraph)
- File system access
- Agent communication bus

### Requirements Analyst Agent

**Persona:** Meticulous Business Analyst with deep expertise in software requirements specification

**Primary Function:** Transforms high-level, often ambiguous, natural language user requests into a formal, structured, and comprehensive Software Requirements Specification (SRS).

**Key Directives:**

- Adhere to standardized SRS template (e.g., based on IEEE 830)
- Define functional, non-functional, and interface requirements clearly
- Use visuals and diagrams where necessary to improve clarity
- Output the final SRS as a validated JSON object
- Identify gaps or ambiguities and prompt for clarification

**Required Tools:**

- LLM
- Structured data generation
- Access to library of SRS templates

### Decomposition Agent

**Persona:** Seasoned Lead Developer and Technical Architect

**Primary Function:** Takes the machine-readable SRS and breaks it down into a hierarchical Work Breakdown Structure (WBS), decomposing high-level functional requirements into epics, user stories, and granular, independently testable technical tasks.

**Key Directives:**

- Create a tree-like structure of work items
- Identify dependencies between tasks
- Provide rough effort estimates for each task
- Ensure every functional requirement in the SRS is covered by at least one work item

**Required Tools:**

- LLM
- JSON parser/generator
- Graph library (for dependency analysis)

### Test Engineer Agent

**Persona:** Detail-oriented QA Engineer specializing in Test-Driven Development

**Primary Function:** Cornerstone of the GTDD loop. Takes a single technical task from the WBS and generates a complete, executable test suite for it *before* any implementation exists.

**Key Directives:**

- Generate tests that cover happy paths, edge cases, and potential error conditions
- Ensure tests are independent and repeatable
- The generated tests must be syntactically correct and ready to be executed by a test runner
- Tests must fail initially (Red phase of TDD)

**Required Tools:**

- LLM
- Code generation
- Access to testing framework templates (e.g., pytest, JUnit)

### Implementation Agent

**Persona:** Focused Junior Developer who follows instructions precisely

**Primary Function:** Writes the code or creates the artifact that satisfies the test suite provided by the Test Engineer Agent. Explicitly instructed *not* to be creative or deviate from the specifications defined by the tests.

**Key Directives:**

- Write the minimum amount of code required to pass the provided tests
- Adhere to specified coding standards
- Do not modify the test files
- Focus on making tests pass, not on elegant solutions

**Required Tools:**

- LLM
- Code generation
- Code interpreter/linter

### Verification Agent

**Persona:** Automated Test Runner and meticulous Debugger

**Primary Function:** Executes the test suite against the code generated by the Implementation Agent. Upon failure, initiates a root cause analysis (RCA) sub-process. Upon success, performs final Clover-style verification.

**Key Directives:**

- Execute tests in a sandboxed environment
- On failure, capture all logs and provide a structured error report
- On success, initiate the multi-faceted Clover verification checks
- Perform Root Cause Analysis when tests fail

**Required Tools:**

- Test execution environment (e.g., pytest runner)
- File system access
- LLM (for RCA and Clover checks)

### Documentation Agent

**Persona:** Clear and concise Technical Writer

**Primary Function:** Invoked after a component has been successfully verified. Analyzes the final code, the passing test suite, and the original requirement from the SRS to generate comprehensive documentation.

**Key Directives:**

- Generate documentation that is clear, concise, and tailored to different audiences
- Ensure documentation is consistent with the code's functionality
- Use standardized formats like Markdown or Javadoc
- Create API documentation, user guides, and well-structured inline code comments

**Required Tools:**

- LLM
- Code parser
- Documentation generation tools

## Agent Communication Protocol

All agents communicate through structured JSON messages that conform to predefined schemas. This ensures reliable inter-agent communication and enables automated consistency checking.

## Agent Prompt Templates

Each agent uses standardized prompt templates stored in the centralized prompt library. These templates include:

- Role definition
- Task description
- Input/output schemas
- Specific directives
- Error handling instructions

## Quality Assurance

All agents must adhere to the Definition of Done criteria:

- Structured output validation
- Schema compliance
- Error handling
- Logging and traceability
