"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
nimport;
{
    SessionManager;
}
from;
'../../src/core/session-manager';
nimport;
{
    ModeManager;
}
from;
'../../src/core/mode-manager';
nimport;
{
    ConfigManager, ConfigTemplates;
}
from;
'../../src/core/config-manager';
nimport;
{
    ErrorHandler, ErrorSeverity, ErrorCategory;
}
from;
'../../src/core/error-handler';
nimport;
{
    CoreInfrastructure;
}
from;
'../../src/core/index';
nimport;
{
    promises;
}
from;
'fs';
nimport;
{
    join;
}
from;
'path';
n;
ndescribe('Phase 1 Core Infrastructure Integration', () => { n; let tempDir; n; let coreFoundation; n; let sessionManager; n; let modeManager; n; let configManager; n; let errorHandler; n; n; beforeAll(async () => { n; }); }); // Create temporary directory for test files\n    tempDir = join(__dirname, '..', 'temp', `test-${Date.now()}`);\n    await fs.mkdir(tempDir, { recursive: true });\n  });\n\n  afterAll(async () => {\n    // Cleanup\n    try {\n      if (coreFoundation) {\n        await coreFoundation.gracefulShutdown();\n      }\n      if (configManager) {\n        await configManager.shutdown();\n      }\n      if (errorHandler) {\n        await errorHandler.shutdown();\n      }\n      await fs.rmdir(tempDir, { recursive: true });\n    } catch (error) {\n      console.warn('Cleanup warning:', error);\n    }\n  });\n\n  describe('Environment Validation', () => {\n    it('should validate system environment successfully', async () => {\n      const validation = await CoreInfrastructure.validateEnvironment();\n      \n      expect(validation).toHaveProperty('valid');\n      expect(validation).toHaveProperty('issues');\n      expect(validation).toHaveProperty('recommendations');\n      \n      if (!validation.valid) {\n        console.warn('Environment issues:', validation.issues);\n        console.warn('Recommendations:', validation.recommendations);\n      }\n    });\n\n    it('should provide comprehensive system information', () => {\n      const systemInfo = CoreInfrastructure.getSystemInfo();\n      \n      expect(systemInfo).toHaveProperty('nodeVersion');\n      expect(systemInfo).toHaveProperty('platform');\n      expect(systemInfo).toHaveProperty('architecture');\n      expect(systemInfo).toHaveProperty('memoryUsage');\n      expect(systemInfo).toHaveProperty('uptime');\n      expect(systemInfo.nodeVersion).toMatch(/^v\\d+\\.\\d+\\.\\d+/);\n    });\n  });\n\n  describe('Session Management', () => {\n    beforeEach(() => {\n      sessionManager = new SessionManager({\n        maxConcurrentSessions: 2,\n        sessionTimeoutMs: 60000,\n        persistentStorage: false,\n        auditLogging: false // Disable for tests\n      });\n    });\n\n    afterEach(async () => {\n      if (sessionManager) {\n        await sessionManager.shutdown();\n      }\n    });\n\n    it('should create and manage sessions successfully', async () => {\n      // Create standalone session\n      const sessionId1 = await sessionManager.createSession('standalone', { test: 'data1' });\n      expect(sessionId1).toBeTruthy();\n      expect(sessionId1).toMatch(/^[0-9a-f-]{36}$/); // UUID format\n      \n      // Create integrated session\n      const sessionId2 = await sessionManager.createSession('integrated', { test: 'data2' });\n      expect(sessionId2).toBeTruthy();\n      expect(sessionId2).not.toBe(sessionId1);\n      \n      // Verify sessions exist\n      const session1 = sessionManager.getSession(sessionId1);\n      const session2 = sessionManager.getSession(sessionId2);\n      \n      expect(session1).toBeTruthy();\n      expect(session1?.mode).toBe('standalone');\n      expect(session1?.context?.test).toBe('data1');\n      \n      expect(session2).toBeTruthy();\n      expect(session2?.mode).toBe('integrated');\n      expect(session2?.context?.test).toBe('data2');\n    });\n\n    it('should enforce session limits', async () => {\n      // Create maximum allowed sessions\n      const session1 = await sessionManager.createSession('standalone');\n      const session2 = await sessionManager.createSession('integrated');\n      \n      // Try to create one more (should fail)\n      await expect(sessionManager.createSession('standalone'))\n        .rejects.toThrow('Maximum concurrent sessions');\n    });\n\n    it('should update session metrics correctly', async () => {\n      const sessionId = await sessionManager.createSession('standalone');\n      \n      // Update metrics\n      const success = await sessionManager.updateSessionMetrics(sessionId, {\n        commandsExecuted: 5,\n        tokensUsed: 1000,\n        errorsEncountered: 1\n      });\n      \n      expect(success).toBe(true);\n      \n      const session = sessionManager.getSession(sessionId);\n      expect(session?.metrics?.commandsExecuted).toBe(5);\n      expect(session?.metrics?.tokensUsed).toBe(1000);\n      expect(session?.metrics?.errorsEncountered).toBe(1);\n    });\n\n    it('should complete sessions successfully', async () => {\n      const sessionId = await sessionManager.createSession('standalone');\n      \n      const completed = await sessionManager.completeSession(sessionId, true);\n      expect(completed).toBe(true);\n      \n      const session = sessionManager.getSession(sessionId);\n      expect(session?.status).toBe('completed');\n      expect(session?.endTime).toBeTruthy();\n    });\n  });\n\n  describe('Mode Management', () => {\n    beforeEach(() => {\n      modeManager = new ModeManager('standalone');\n    });\n\n    afterEach(async () => {\n      if (modeManager) {\n        await modeManager.shutdown();\n      }\n    });\n\n    it('should initialize with correct default mode', () => {\n      const currentMode = modeManager.getCurrentMode();\n      \n      expect(currentMode.mode).toBe('standalone');\n      expect(currentMode.config).toHaveProperty('features');\n      expect(currentMode.config).toHaveProperty('limits');\n      expect(currentMode.capabilities).toHaveProperty('cliInterface');\n    });\n\n    it('should switch modes successfully', async () => {\n      // Switch to integrated mode\n      const switched = await modeManager.switchMode('integrated');\n      expect(switched).toBe(true);\n      \n      const currentMode = modeManager.getCurrentMode();\n      expect(currentMode.mode).toBe('integrated');\n      expect(currentMode.config.features.claudeCodeIntegration).toBe(true);\n    });\n\n    it('should provide accurate capability information', () => {\n      expect(modeManager.hasCapability('cliInterface')).toBe(true);\n      expect(modeManager.hasCapability('localExecution')).toBe(true);\n      expect(modeManager.isFeatureEnabled('cliInterface')).toBe(true);\n    });\n\n    it('should generate comprehensive mode reports', () => {\n      const report = modeManager.generateModeReport();\n      \n      expect(report).toHaveProperty('summary');\n      expect(report).toHaveProperty('details');\n      expect(report.details).toHaveProperty('currentMode');\n      expect(report.details).toHaveProperty('uptime');\n      expect(report.details).toHaveProperty('featuresEnabled');\n      expect(report.summary).toContain('standalone mode');\n    });\n  });\n\n  describe('Configuration Management', () => {\n    beforeEach(() => {\n      const configPath = join(tempDir, 'test-config.json');\n      configManager = new ConfigManager(configPath);\n    });\n\n    afterEach(async () => {\n      if (configManager) {\n        await configManager.shutdown();\n      }\n    });\n\n    it('should initialize with default configuration', async () => {\n      const initialized = await configManager.initialize();\n      expect(initialized).toBe(true);\n      \n      const config = configManager.getConfig();\n      expect(config).toHaveProperty('system');\n      expect(config).toHaveProperty('session');\n      expect(config).toHaveProperty('mode');\n      expect(config).toHaveProperty('performance');\n    });\n\n    it('should load configuration templates successfully', async () => {\n      await configManager.initialize();\n      \n      // Load enterprise template\n      const loaded = await configManager.loadTemplate('enterprise');\n      expect(loaded).toBe(true);\n      \n      const config = configManager.getConfig();\n      expect(config.system.name).toBe('Phoenix Code Lite Enterprise');\n      expect(config.mode.defaultMode).toBe('integrated');\n      expect(config.session.maxConcurrentSessions).toBe(10);\n    });\n\n    it('should validate configuration correctly', async () => {\n      await configManager.initialize();\n      \n      const validation = configManager.validateConfig();\n      expect(validation).toHaveProperty('valid');\n      expect(validation).toHaveProperty('errors');\n      expect(validation).toHaveProperty('warnings');\n      \n      if (!validation.valid) {\n        console.warn('Configuration validation errors:', validation.errors);\n      }\n    });\n\n    it('should update configuration with validation', async () => {\n      await configManager.initialize();\n      \n      const updated = await configManager.updateConfig({\n        session: {\n          maxConcurrentSessions: 5,\n          sessionTimeoutMs: 7200000,\n          persistentStorage: true,\n          auditLogging: true\n        }\n      });\n      \n      expect(updated).toBe(true);\n      \n      const config = configManager.getConfig();\n      expect(config.session.maxConcurrentSessions).toBe(5);\n      expect(config.session.sessionTimeoutMs).toBe(7200000);\n    });\n\n    it('should provide configuration summary', async () => {\n      await configManager.initialize();\n      \n      const summary = configManager.getConfigSummary();\n      expect(summary).toHaveProperty('template');\n      expect(summary).toHaveProperty('mode');\n      expect(summary).toHaveProperty('environment');\n      expect(summary).toHaveProperty('features');\n      expect(summary).toHaveProperty('limits');\n      expect(Array.isArray(summary.features)).toBe(true);\n      expect(Array.isArray(summary.limits)).toBe(true);\n    });\n  });\n\n  describe('Error Handling', () => {\n    beforeEach(() => {\n      errorHandler = new ErrorHandler();\n    });\n\n    afterEach(async () => {\n      if (errorHandler) {\n        await errorHandler.shutdown();\n      }\n    });\n\n    it('should handle errors with comprehensive processing', async () => {\n      const error = new Error('Test validation error');\n      \n      const result = await errorHandler.handleError(error, {\n        source: 'test-component',\n        category: ErrorCategory.VALIDATION,\n        severity: ErrorSeverity.MEDIUM,\n        sessionId: 'test-session-123'\n      });\n      \n      expect(result).toHaveProperty('handled');\n      expect(result).toHaveProperty('recovered');\n      expect(result).toHaveProperty('action');\n      expect(result.handled).toBe(true);\n      expect(result.action).toBe('validation_failed');\n    });\n\n    it('should classify errors correctly', async () => {\n      // Test validation error\n      const validationError = new Error('Invalid input format');\n      const validationResult = await errorHandler.handleError(validationError);\n      expect(validationResult.action).toBe('validation_failed');\n      \n      // Test network error\n      const networkError = new Error('Network connection failed');\n      const networkResult = await errorHandler.handleError(networkError);\n      expect(networkResult.action).toBe('network_error');\n      expect(networkResult.retry).toBe(true);\n    });\n\n    it('should provide error statistics and insights', async () => {\n      // Generate some test errors\n      await errorHandler.handleError(new Error('Error 1'), { source: 'component-a' });\n      await errorHandler.handleError(new Error('Error 2'), { source: 'component-b' });\n      await errorHandler.handleError(new Error('Network error'), { category: ErrorCategory.NETWORK });\n      \n      const stats = errorHandler.getErrorStats();\n      expect(stats).toHaveProperty('totalErrors');\n      expect(stats).toHaveProperty('errorsByCategory');\n      expect(stats).toHaveProperty('errorsBySeverity');\n      expect(stats).toHaveProperty('recentErrors');\n      expect(stats.totalErrors).toBeGreaterThan(0);\n    });\n\n    it('should provide recovery suggestions', async () => {\n      const error = new Error('Configuration file not found');\n      \n      const result = await errorHandler.handleError(error, {\n        category: ErrorCategory.CONFIGURATION\n      });\n      \n      // Simulate getting the error info for suggestions\n      const mockErrorInfo = {\n        id: 'test-error',\n        timestamp: new Date(),\n        severity: ErrorSeverity.HIGH,\n        category: ErrorCategory.CONFIGURATION,\n        source: 'config-loader',\n        message: 'Configuration file not found',\n        recoverable: true,\n        retryable: false\n      };\n      \n      const suggestions = errorHandler.getRecoverySuggestions(mockErrorInfo);\n      expect(Array.isArray(suggestions)).toBe(true);\n      expect(suggestions.length).toBeGreaterThan(0);\n      expect(suggestions).toContain('Validate configuration file syntax');\n    });\n  });\n\n  describe('Core Foundation Integration', () => {\n    beforeEach(async () => {\n      const configPath = join(tempDir, 'core-config.json');\n      configManager = new ConfigManager(configPath);\n      await configManager.initialize();\n      \n      const config = configManager.getConfig();\n      coreFoundation = new CoreFoundation(config);\n    });\n\n    afterEach(async () => {\n      if (coreFoundation) {\n        await coreFoundation.gracefulShutdown();\n      }\n    });\n\n    it('should initialize all core components successfully', async () => {\n      const initialized = await coreFoundation.initialize();\n      expect(initialized).toBe(true);\n      expect(coreFoundation.isInitialized()).toBe(true);\n      \n      const components = coreFoundation.getComponents();\n      expect(components).toHaveProperty('sessionManager');\n      expect(components).toHaveProperty('modeManager');\n      expect(components).toHaveProperty('auditLogger');\n    });\n\n    it('should provide accurate system status', async () => {\n      await coreFoundation.initialize();\n      \n      const status = coreFoundation.getSystemStatus();\n      expect(status).toHaveProperty('status');\n      expect(status).toHaveProperty('details');\n      expect(status).toHaveProperty('components');\n      expect(['healthy', 'warning', 'critical']).toContain(status.status);\n      expect(status.components.sessionManager).toBe('online');\n      expect(status.components.modeManager).toBe('online');\n    });\n\n    it('should record and track performance metrics', async () => {\n      await coreFoundation.initialize();\n      \n      // Record some test metrics\n      coreFoundation.recordRequest(150, false); // 150ms, no error\n      coreFoundation.recordRequest(200, true);  // 200ms, with error\n      coreFoundation.recordRequest(100, false); // 100ms, no error\n      \n      const status = coreFoundation.getSystemStatus();\n      expect(status.details.performance.totalRequests).toBe(3);\n      expect(status.details.performance.averageResponseTime).toBeGreaterThan(0);\n      expect(status.details.performance.errorRate).toBeCloseTo(1/3, 2);\n    });\n  });\n\n  describe('End-to-End Integration', () => {\n    it('should perform complete initialization and operation cycle', async () => {\n      // Initialize configuration\n      const configPath = join(tempDir, 'e2e-config.json');\n      configManager = new ConfigManager(configPath);\n      const configInitialized = await configManager.initialize();\n      expect(configInitialized).toBe(true);\n      \n      // Initialize error handler\n      errorHandler = new ErrorHandler();\n      \n      // Initialize core foundation\n      const config = configManager.getConfig();\n      coreFoundation = new CoreFoundation(config);\n      const coreInitialized = await coreFoundation.initialize();\n      expect(coreInitialized).toBe(true);\n      \n      // Get components for testing\n      const components = coreFoundation.getComponents();\n      const sessionManager = components.sessionManager;\n      const modeManager = components.modeManager;\n      \n      // Create and manage a session\n      const sessionId = await sessionManager.createSession('standalone', {\n        testData: 'e2e-test'\n      });\n      expect(sessionId).toBeTruthy();\n      \n      // Update session with activity\n      await sessionManager.updateSessionMetrics(sessionId, {\n        commandsExecuted: 3,\n        tokensUsed: 500\n      });\n      \n      // Switch mode\n      const modeSwitched = await modeManager.switchMode('integrated');\n      expect(modeSwitched).toBe(true);\n      \n      // Handle an error\n      const errorResult = await errorHandler.handleError(\n        new Error('E2E test error'),\n        { source: 'e2e-test', sessionId }\n      );\n      expect(errorResult.handled).toBe(true);\n      \n      // Complete session\n      const sessionCompleted = await sessionManager.completeSession(sessionId, true);\n      expect(sessionCompleted).toBe(true);\n      \n      // Verify system status\n      const finalStatus = coreFoundation.getSystemStatus();\n      expect(finalStatus.status).toMatch(/healthy|warning/);\n      \n      // Cleanup\n      await configManager.shutdown();\n      await errorHandler.shutdown();\n      await coreFoundation.gracefulShutdown();\n    }, 30000); // Extended timeout for comprehensive test\n  });\n});
//# sourceMappingURL=phase-1-infrastructure.test.js.map